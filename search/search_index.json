{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Aioinject is a dependency injection and service locator library, made to easily work with dependency injection using python type annotations.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip or your favorite package manager: <pre><code>pip install aioinject\n</code></pre></p>"},{"location":"#example","title":"Example","text":"<pre><code>from aioinject import Scoped, Singleton, SyncContainer\n\n\nclass Database:\n    def __init__(self) -&gt; None:\n        self._storage = {1: \"Username\"}\n\n    def get(self, id: int) -&gt; str | None:\n        return self._storage.get(id)\n\n\nclass UserService:\n    def __init__(\n        self,\n        database: Database,  # &lt;- `Database` is injected here\n    ) -&gt; None:\n        self._database = database\n\n    def get(self, id: int) -&gt; str:\n        user = self._database.get(id)\n        if user is None:\n            raise ValueError\n        return user\n\n\ncontainer = SyncContainer()\ncontainer.register(\n    Singleton(Database),\n    Scoped(UserService),\n)\n\nwith (\n    container,  # Singletons are managed\n    container.context() as context,\n):\n    service = context.resolve(UserService)\n    user = service.get(1)\n    print(user)  # \"Username\"\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Benchmark tries to resolve this set of dependencies: <pre><code>UseCase\n  ServiceA\n    RepositoryA\n      Session\n  ServiceB\n    RepositoryB\n      Session\n</code></pre></p>"},{"location":"benchmarks/#async","title":"Async","text":"<p>Async API is used, <code>Session</code> dependency ran as a context manager, equivalent to <pre><code>async with create_session_cm() as session:\n    repo_a = RepositoryA(session=session)\n    repo_b = RepositoryB(session=session)\n    svc_a = ServiceA(repository=repo_a)\n    svc_b = ServiceB(repository=repo_b)\n    UseCase(service_a=svc_a, service_b=svc_b)\n</code></pre></p> Name iterations total mean median python 100000 194.520ms 1.945\u03bcs 1.900\u03bcs dishka 100000 600.378ms 6.004\u03bcs 4.600\u03bcs aioinject 100000 611.180ms 6.112\u03bcs 5.100\u03bcs adriangb/di 100000 623.968ms 6.240\u03bcs 6.200\u03bcs wireup 100000 1394.453ms 13.945\u03bcs 13.900\u03bcs <p>Note</p> <p>This set of benchmarks is smaller, since not all libraries support scopes or context manager dependencies</p>"},{"location":"benchmarks/#sync","title":"Sync","text":"<p>All libraries use synchronous API with no context managers, equivalent to <pre><code>session = Session()\nrepo_a = RepositoryA(session=session)\nrepo_b = RepositoryB(session=session)\nsvc_a = ServiceA(repository=repo_a)\nsvc_b = ServiceB(repository=repo_b)\nUseCase(service_a=svc_a, service_b=svc_b)\n</code></pre></p> Name iterations total mean median python 100000 73.443ms 0.734\u03bcs 0.700\u03bcs dependency-injector 100000 154.265ms 1.543\u03bcs 1.500\u03bcs rodi 100000 208.062ms 2.081\u03bcs 2.000\u03bcs aioinject 100000 343.069ms 3.431\u03bcs 2.700\u03bcs dishka 100000 359.610ms 3.596\u03bcs 3.000\u03bcs adriangb/di 100000 426.652ms 4.267\u03bcs 4.200\u03bcs lagom 100000 1101.359ms 11.014\u03bcs 10.400\u03bcs wireup 100000 1436.985ms 14.370\u03bcs 13.500\u03bcs punq 5000 9771.656ms (extrapolated) 97.717\u03bcs 91.000\u03bcs"},{"location":"extensions/","title":"Extensions","text":"<p>Extensions are a mechanism to extend container and context behavior, similar to a plugin system.</p>"},{"location":"extensions/#container-extensions","title":"Container Extensions","text":""},{"location":"extensions/#lifespan","title":"Lifespan","text":"<p>Lifespan extension could be used to execute code when container enters and exits <pre><code>import asyncio\nimport contextlib\nfrom collections.abc import AsyncIterator\n\nfrom aioinject import Container\nfrom aioinject.extensions import LifespanExtension\n\n\nclass MyLifespanExtension(LifespanExtension):\n    @contextlib.asynccontextmanager\n    async def lifespan(\n        self,\n        container: Container,  # noqa: ARG002\n    ) -&gt; AsyncIterator[None]:\n        print(\"Enter\")\n        yield None\n        print(\"Exit\")\n\n\nasync def main() -&gt; None:\n    container = Container(extensions=[MyLifespanExtension()])\n    async with container:\n        # print(\"Enter\") is executed.\n        pass\n        # print(\"Exit\") is executed.\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p>"},{"location":"extensions/#oninit","title":"OnInit","text":"<p>OnInit extension is executed when container's <code>__init__</code> is called, this could be used for example to register dependencies in it: <pre><code>from datetime import datetime\nfrom typing import NewType\n\nfrom aioinject import Container, SyncContainer, Transient\nfrom aioinject.extensions import OnInitExtension\n\n\nNow = NewType(\"Now\", datetime)\n\n\nclass TimeExtension(OnInitExtension):\n    def on_init(\n        self,\n        container: Container | SyncContainer,\n    ) -&gt; None:\n        container.register(Transient(datetime.now, Now))\n\n\ncontainer = SyncContainer(extensions=[TimeExtension()])\nwith container.context() as ctx:\n    print(ctx.resolve(Now))\n</code></pre></p>"},{"location":"extensions/#onresolve-onresolvesync","title":"OnResolve / OnResolveSync","text":"<p>On resolve extension is called when individual dependency is provided within a context: <pre><code>import logging\nfrom typing import TypeVar\n\nfrom aioinject import Context\nfrom aioinject.context import ProviderRecord\nfrom aioinject.extensions import OnResolveExtension\n\n\nT = TypeVar(\"T\")\n\n\nlogger = logging.getLogger(__name__)\n\n\nclass MyExtension(OnResolveExtension):\n    async def on_resolve(\n        self,\n        context: Context,  # noqa: ARG002\n        provider: ProviderRecord[T],\n        instance: T,  # noqa: ARG002\n    ) -&gt; None:\n        logger.info(\"%s type was provided!\", provider.info.type_)\n</code></pre></p>"},{"location":"providers/","title":"Providers","text":"<p>Aioinject implements multiple different providers,  they work similarly to service lifetimes in other libraries, such as DI in .NET Core</p>"},{"location":"providers/#scoped","title":"Scoped","text":"<p>Objects provided with <code>Scoped</code> provider would be cached within context. <pre><code>import aioinject\n\n\ncontainer = aioinject.SyncContainer()\ncontainer.register(aioinject.Scoped(list))\n\nwith container, container.context() as ctx:\n    object_1 = ctx.resolve(list)\n    object_2 = ctx.resolve(list)\n    assert object_1 is object_2\n</code></pre></p>"},{"location":"providers/#transient","title":"Transient","text":"<p><code>Transient</code> provider would provide different instances even if used within same context  <pre><code>import aioinject\n\n\ncontainer = aioinject.SyncContainer()\ncontainer.register(aioinject.Transient(list))\n\nwith container.context() as ctx:\n    object_1 = ctx.resolve(list)\n    object_2 = ctx.resolve(list)\n    assert object_1 is not object_2\n</code></pre></p>"},{"location":"providers/#singleton","title":"Singleton","text":"<p><code>Singleton</code> works as you expect - there would be only one instance of a singleton object, bound to a specific container <pre><code>import aioinject\n\n\ncontainer = aioinject.SyncContainer()\ncontainer.register(aioinject.Singleton(list))\n\nwith container.context() as ctx:\n    object_1 = ctx.resolve(list)\n\nwith container.context() as ctx:\n    object_2 = ctx.resolve(list)\n\nassert object_1 is object_2\n</code></pre></p>"},{"location":"providers/#object","title":"Object","text":"<p><code>Object</code> provider just returns an object provided to it: <pre><code>from aioinject import Object\n\nObject(42)\n</code></pre> would always return 42</p>"},{"location":"usage-guide/","title":"Usage Guide","text":""},{"location":"usage-guide/#registering-dependencies","title":"Registering Dependencies","text":"<p>To register a dependency pass provider you want into <code>Container.register</code>: <pre><code>from aioinject import Container, Scoped\n\n\nclass MyClass:\n    pass\n\n\ncontainer = Container()\ncontainer.register(Scoped(MyClass))\n</code></pre> You can pass multiple providers into the same call if needed: <pre><code>container.register(\n    Scoped(A),\n    Scoped(B),\n)\n</code></pre></p>"},{"location":"usage-guide/#generic-dependencies","title":"Generic Dependencies","text":"<p>Aioinject supports registering unbound generic classes and passing generic parameters when resolving them. <pre><code>from typing import Final, Generic, TypeVar\n\nfrom aioinject import Object, Scoped, SyncContainer\n\n\nT = TypeVar(\"T\")\n\n\nclass Box(Generic[T]):\n    def __init__(self, value: T) -&gt; None:\n        self.value: Final = value\n\n    def __repr__(self) -&gt; str:\n        return f\"Box({self.value!r})\"\n\n\ncontainer = SyncContainer()\ncontainer.register(\n    Scoped(Box),\n    Object(\"string value\"),\n    Object(42),\n)\n\nwith container, container.context() as context:\n    int_box = context.resolve(Box[int])\n    print(int_box)  # Box(42)\n\n    str_box = context.resolve(Box[str])\n    print(str_box)  # Box('string value')\n\n    container.register(Object(Box(\"bound\"), interface=Box[str]))\n\n    box_str = context.resolve(Box[str])\n    print(box_str)  # Box('bound')\n</code></pre> You can register bound generic type and it would take priority: <pre><code>container.register(Object(Box(\"bound\"), interface=Box[str]))\n\nwith container.context() as context:\n    box_str = context.resolve(Box[str]) \n    print(box_str)  # Box('bound')\n</code></pre></p>"},{"location":"usage-guide/#iterable-dependencies","title":"Iterable dependencies","text":"<p>Sometimes there's a need to register and resolve multiple dependencies of the same type/interface. Iterable dependencies in aioinject work similarly to <code>Enumerable</code> dependencies in <code>C#</code>/<code>.NET</code> - all dependencies are instantiated and provided.</p> <pre><code>from collections.abc import Sequence\n\nfrom aioinject import Singleton, SyncContainer\n\n\nclass Logger:\n    pass\n\n\nclass FileLogger(Logger):\n    pass\n\n\nclass DatabaseLogger(Logger):\n    pass\n\n\nclass StreamLogger(Logger):\n    pass\n\n\ncontainer = SyncContainer()\ncontainer.register(\n    Singleton(FileLogger, Logger),\n    Singleton(DatabaseLogger, Logger),\n    Singleton(StreamLogger, Logger),\n)\n\nwith container, container.context() as context:\n    loggers = context.resolve(Sequence[Logger])  # type: ignore[type-abstract]\n    print(loggers)  # [&lt;FileLogger&gt;, &lt;DatabaseLogger&gt;, &lt;StreamLogger&gt;]\n</code></pre> <p>Warning</p> <p>When multiple providers are registered with same interface the most recent one would be provided: <pre><code>context.resolve(Logger)  # &lt;StreamLogger&gt;\n</code></pre></p> <p>Note</p> <p>Currently iterable dependencies are always provided in a <code>list</code> container. </p>"},{"location":"usage-guide/#context-managers-resources","title":"Context Managers / Resources","text":"<p>Applications often need to close dependencies after they're done using them, this can be done by registering a function decorated with <code>@contextlib.contextmanager</code> or <code>@contextlib.asynccontextmanager</code>. Internally aioinject would use <code>contextlib.ExitStack</code> or <code>contextlib.AsyncExitStack</code> to manage them.</p> <pre><code>import contextlib\nfrom collections.abc import Iterator\n\nimport aioinject\nfrom aioinject import Scoped, Singleton\n\n\n@contextlib.contextmanager\ndef singleton_dependency() -&gt; Iterator[int]:\n    print(\"Singleton Startup\")\n    yield 42\n    print(\"Singleton Shutdown\")\n\n\n@contextlib.contextmanager\ndef scoped_dependency(number: int) -&gt; Iterator[str]:\n    print(\"Scoped Startup\")\n    yield str(number)\n    print(\"Scoped Shutdown\")\n\n\ncontainer = aioinject.SyncContainer()\ncontainer.register(Singleton(singleton_dependency))\ncontainer.register(Scoped(scoped_dependency))\n\nwith container:  # noqa: SIM117\n    with container.context() as ctx:\n        value = ctx.resolve(str)  # Singleton Startup, Scoped Startup\n        print(repr(value))  # '42'\n    # Scoped Shutdown\n# Singleton Shutdown\n</code></pre>"},{"location":"usage-guide/#handling-errors","title":"Handling Errors","text":"<p>If Exceptions are raised inside a scope they're propagated into context managers, if you're not wrapping an already existing context manager (e.g. SQLAlchemy's <code>Session.begin</code>) you should use <code>try-except-finally</code> to correctly close your dependencies. <pre><code>@contextlib.contextmanager\ndef dependency() -&gt; Iterator[int]:\n    obj = SomeObject()\n    try:\n        yield obj\n    except:\n        ... # Error handling code\n    finally:\n        obj.close()\n</code></pre></p>"},{"location":"usage-guide/#managing-application-lifetime","title":"Managing Application Lifetime","text":"<p>In order for container to close singleton dependencies on application shutdown you need to use container as a context manager. <pre><code>import asyncio\n\nfrom aioinject import Container\n\n\nasync def main() -&gt; None:\n    container = Container()\n\n    async with container:\n        ...\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> This also runs <code>LifespanExtension</code> and <code>LifespanSyncExtension</code></p>"},{"location":"integrations/aiogram/","title":"Aiogram","text":"<p>Aiogram integration is achieved with <code>AioInjectMiddleware</code>, which you could register on individual observers or on all observers in a router via <code>add_to_router</code> method:</p> <pre><code>import asyncio\n\nfrom aiogram import Bot, Dispatcher, Router\nfrom aiogram.filters import Command\nfrom aiogram.types import Message\n\nfrom aioinject import Container, Injected, Object\nfrom aioinject.ext.aiogram import AioInjectMiddleware, inject\n\n\nrouter = Router()\n\n\n@router.message(\n    Command(commands=[\"start\"]),\n)\n@inject\nasync def start(\n    message: Message,\n    value: Injected[int],\n) -&gt; None:\n    await message.reply(f\"Injected value is {value}\")\n\n\nasync def main() -&gt; None:\n    container = Container()\n    container.register(Object(42))\n\n    middleware = AioInjectMiddleware(container)\n    middleware.add_to_router(router)\n\n    dispatcher = Dispatcher()\n    dispatcher.include_router(router)\n\n    async with (\n        container,\n        Bot(token=\"token-here\") as bot,  # noqa: S106\n    ):\n        await dispatcher.start_polling(bot)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"integrations/django/","title":"Django","text":""},{"location":"integrations/django/#subclass-aioinjectmiddleware","title":"Subclass AioinjectMiddleware","text":"<p>Since Django doesn't allow you to parametrize middleware (e.g. like starlette does) we need to subclass <code>AioinjectMiddleware</code>:</p> <p>app/di.py<pre><code>import functools\nimport random\n\nfrom aioinject import Scoped, SyncContainer\nfrom aioinject.ext.django import SyncAioinjectMiddleware\n\n\n@functools.cache\ndef create_container() -&gt; SyncContainer:\n    container = SyncContainer()\n    container.register(\n        Scoped(lambda: random.randint(1, 1000), interface=int),  # noqa: S311\n    )\n    return container\n\n\nclass DIMiddleware(SyncAioinjectMiddleware):\n    container = create_container()\n</code></pre> alternatively you can declare a property if needed: <pre><code>class DIMiddleware(SyncAioinjectMiddleware):\n    @property\n    def container(self) -&gt; SyncContainer:\n        return create_container()\n</code></pre></p>"},{"location":"integrations/django/#add-middleware-to-your-settingsmiddleware","title":"Add middleware to your <code>settings.MIDDLEWARE</code>","text":"app/settings.py<pre><code>MIDDLEWARE = [\n    \"django.middleware.security.SecurityMiddleware\",\n    \"django.contrib.sessions.middleware.SessionMiddleware\",\n    \"django.middleware.common.CommonMiddleware\",\n    \"django.middleware.csrf.CsrfViewMiddleware\",\n    \"django.contrib.auth.middleware.AuthenticationMiddleware\",\n    \"django.contrib.messages.middleware.MessageMiddleware\",\n    \"django.middleware.clickjacking.XFrameOptionsMiddleware\",\n    \"app.di.DIMiddleware\",\n]\n</code></pre>"},{"location":"integrations/django/#mark-your-view-with-inject","title":"Mark your view with <code>@inject</code>","text":"views.py<pre><code>from django.http import HttpRequest, HttpResponse\n\nfrom aioinject import Injected\nfrom aioinject.ext.django import inject\n\n\n@inject\ndef root_view(\n    _: HttpRequest,\n    dependency: Injected[int],\n) -&gt; HttpResponse:\n    return HttpResponse(content=f\"{dependency}\")\n</code></pre> <p>Warning</p> <p>Since django and rest_framework pass request as a positional argument your request parameter should always be declared first.</p>"},{"location":"integrations/django/#integration-with-rest-framework","title":"Integration with Rest Framework","text":"<p><code>@inject</code> decorator should work with any function/method that accepts  <code>django.http.HttpRequest</code>  or <code>rest_framework.request.Request</code>: <pre><code>from rest_framework.request import Request\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework.viewsets import ViewSet\n\nfrom aioinject import Injected\nfrom aioinject.ext.django import inject\n\n\nclass ViewExample(APIView):\n    @inject\n    def get(self, _: Request, number: Injected[int]) -&gt; Response:\n        return Response({\"value\": number})\n\n\nclass ViewSetExample(ViewSet):\n    @inject\n    def retrieve(\n        self,\n        _: Request,\n        pk: int,\n        number: Injected[int],\n    ) -&gt; Response:\n        return Response({\"id\": pk, \"value\": number})\n</code></pre></p>"},{"location":"integrations/fastapi/","title":"FastAPI","text":"<p>To integrate with FastAPI you need to add a <code>AioinjectMiddleware</code> and optionally a lifespan if you use context manager dependencies: <pre><code>import contextlib\nfrom collections.abc import AsyncIterator\n\nimport uvicorn\nfrom fastapi import FastAPI\n\nfrom aioinject import Container, Injected, Object\nfrom aioinject.ext.fastapi import AioInjectMiddleware, FastAPIExtension, inject\n\n\ncontainer = Container(\n    extensions=[FastAPIExtension()],  # (1)!\n)\ncontainer.register(Object(42))\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(_: FastAPI) -&gt; AsyncIterator[None]:\n    async with container:  # (2)!\n        yield\n\n\ndef create_app() -&gt; FastAPI:\n    app = FastAPI(lifespan=lifespan)\n    app.add_middleware(AioInjectMiddleware, container=container)  # (3)!\n\n    @app.get(\"/\")\n    @inject\n    async def root(number: Injected[int]) -&gt; int:\n        return number\n\n    return app\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre></p> <ol> <li>(Optionally) if you want to inject <code>Request</code> and <code>BackgroundTasks</code> through aioinject - add a <code>FastAPIExtension</code></li> <li>Manage container lifespan inside an ASGI lifespan</li> <li>Add middleware to your app</li> </ol>"},{"location":"integrations/litestar/","title":"Litestar","text":"<p>Litestar integration comes with a plugin, you just need to add it to litestar app: <pre><code>import uvicorn\nfrom litestar import Litestar, get\n\nfrom aioinject import Container, Injected, Object\nfrom aioinject.ext.litestar import AioInjectPlugin, inject\n\n\ncontainer = Container()\ncontainer.register(Object(42))\n\n\n@get(\"/\")\n@inject\nasync def function_route(\n    number: Injected[int],\n) -&gt; int:\n    return number\n\n\ndef create_app() -&gt; Litestar:\n    return Litestar(\n        [function_route],\n        plugins=[AioInjectPlugin(container=container)],\n    )\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre></p>"},{"location":"integrations/strawberry-graphql/","title":"Strawberry GraphQL","text":"<p>Aioinject integrates with <code>strawberry-graphql</code> using a custom extension:</p> <pre><code>from typing import Any\n\nimport strawberry\nimport uvicorn\nfrom strawberry import Schema\nfrom strawberry.asgi import GraphQL\n\nimport aioinject\nfrom aioinject import Injected\nfrom aioinject.ext.strawberry import AioInjectExtension, inject  # (1)!\n\n\ncontainer = aioinject.Container()\ncontainer.register(aioinject.Object(42))\n\n\n@strawberry.type\nclass Query:\n    @strawberry.field\n    @inject\n    async def number(self, number: Injected[int]) -&gt; int:\n        return number\n\n\ndef create_app() -&gt; GraphQL[Any, Any]:\n    schema = Schema(\n        query=Query,\n        extensions=[\n            AioInjectExtension(container=container),\n        ],\n    )\n    return GraphQL(schema=schema)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre> <ol> <li>Note that <code>inject</code> is imported from <code>aioinject.ext.strawberry</code></li> </ol>"},{"location":"integrations/strawberry-graphql/#usage-with-custom-context-class","title":"Usage with custom Context class","text":"<p>Default integration relies on strawberry-graphql context being a dictionary, you have to set  <code>inject.context_getter</code> and <code>AioinjectExtension.context_setter</code> if you want to use a custom class.</p> <pre><code>from __future__ import annotations\n\nimport dataclasses\nimport functools\nfrom typing import Any, ParamSpec, TypeVar\n\nimport strawberry\nimport uvicorn\nfrom starlette.requests import Request\nfrom starlette.responses import Response\nfrom starlette.websockets import WebSocket\nfrom strawberry import Schema\nfrom strawberry.asgi import GraphQL\n\nimport aioinject\nfrom aioinject import Injected\nfrom aioinject.ext.strawberry import AioInjectExtension\nfrom aioinject.ext.strawberry import inject as base_inject\n\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\n\ndef context_getter(\n    context: Context,\n) -&gt; aioinject.Context | aioinject.SyncContext:\n    return context.aioinject_context  # type: ignore[return-value]\n\n\ndef context_setter(\n    context: Context,\n    aioinject_context: aioinject.Context | aioinject.SyncContext,\n) -&gt; None:\n    context.aioinject_context = aioinject_context\n\n\ninject = functools.partial(base_inject, context_getter=context_getter)\n\n\n@dataclasses.dataclass(slots=True, kw_only=True)\nclass Context:\n    request: Request | WebSocket\n    response: Response | WebSocket\n\n    aioinject_context: aioinject.Context | aioinject.SyncContext | None = None\n\n\n@strawberry.type\nclass Query:\n    @strawberry.field\n    @inject\n    async def number(self, number: Injected[int]) -&gt; int:\n        return number\n\n\nclass MyGraphQL(GraphQL):\n    async def get_context(\n        self,\n        request: Request | WebSocket,\n        response: Response | WebSocket,\n    ) -&gt; Any:\n        return Context(request=request, response=response)\n\n\ndef create_app() -&gt; GraphQL[Any, Any]:\n    container = aioinject.Container()\n    container.register(aioinject.Object(42))\n\n    schema = Schema(\n        query=Query,\n        extensions=[\n            AioInjectExtension(\n                container=container,\n                context_setter=context_setter,\n            ),\n        ],\n    )\n    return MyGraphQL(schema=schema)\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(\"main:create_app\", factory=True, reload=True)\n</code></pre>"},{"location":"internals/code-compilation/","title":"Code Compilation","text":"<p>Internally when <code>Context.resolve</code> is called aioinject compiled whole dependency graph into a single function and then uses it to resolve that specific type.</p> <p>For example given a setup like this <pre><code>import asyncio\nimport contextlib\nfrom collections.abc import AsyncIterator\nfrom datetime import datetime\nfrom typing import NewType\n\nfrom aioinject import (\n    Container,\n    Object,\n    Scoped,\n    Singleton,\n    Transient,\n)\n\n\nclass SingletonClient:\n    pass\n\n\nclass DBConnection:\n    pass\n\n\n@contextlib.asynccontextmanager\nasync def setup_db_connection() -&gt; AsyncIterator[DBConnection]:\n    yield DBConnection()\n\n\nNow = NewType(\"Now\", datetime)\n\n\nclass Service:\n    def __init__(\n        self,\n        now_a: Now,\n        now_b: Now,\n        int_object: int,\n        connection: DBConnection,\n        client: SingletonClient,\n    ) -&gt; None:\n        self._now_a = now_a\n        self._now_b = now_b\n        self._int = int_object\n        self._connection = connection\n        self._client = client\n\n\nasync def main() -&gt; None:\n    container = Container()\n    container.register(\n        Singleton(SingletonClient),\n        Scoped(setup_db_connection),\n        Object(42),\n        Transient(lambda: datetime.now(), interface=Now),  # noqa: DTZ005\n        Scoped(Service),\n    )\n\n    async with container, container.context() as context:\n        await context.resolve(Service)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre></p> <p>Generated factory function would look like this:</p> <pre><code>async def factory(scopes: \"Mapping[BaseScope, Context]\") -&gt; \"T\":\n    lifetime_scope_cache = scopes[lifetime_scope].cache # (1)!\n    lifetime_scope_exit_stack = scopes[lifetime_scope].exit_stack\n    request_scope_cache = scopes[request_scope].cache\n    request_scope_exit_stack = scopes[request_scope].exit_stack\n\n    Service_now_a_Now_instance = Service_now_a_Now_provider.provide({})\n    Service_now_b_Now_instance = Service_now_b_Now_provider.provide({})\n\n    int_instance = int_provider.provide({})\n\n    if ( # (2)!\n        DBConnection_instance := request_scope_cache.get(\n            DBConnection_type, NotInCache\n        )\n    ) is NotInCache:\n        DBConnection_instance = (\n            await request_scope_exit_stack.enter_async_context(\n                DBConnection_provider.provide({})\n            )\n        )\n        request_scope_cache[DBConnection_type] = DBConnection_instance # (3)!\n\n    if (\n        SingletonClient_instance := lifetime_scope_cache.get(\n            SingletonClient_type, NotInCache\n        )\n    ) is NotInCache:\n        async with scopes[lifetime_scope].lock: # (4)!\n            if (\n                SingletonClient_instance := lifetime_scope_cache.get(\n                    SingletonClient_type, NotInCache\n                )\n            ) is NotInCache:\n                SingletonClient_instance = SingletonClient_provider.provide({})\n                lifetime_scope_cache[SingletonClient_type] = (\n                    SingletonClient_instance\n                )\n\n    if (\n        Service_instance := request_scope_cache.get(Service_type, NotInCache)\n    ) is NotInCache:\n        Service_instance = Service_provider.provide(\n            {\n                \"now_a\": Service_now_a_Now_instance,\n                \"now_b\": Service_now_b_Now_instance,\n                \"int_object\": int_instance,\n                \"connection\": DBConnection_instance,\n                \"client\": SingletonClient_instance,\n            }\n        )\n        request_scope_cache[Service_type] = Service_instance\n\n    return Service_instance\n</code></pre> <ol> <li>Used scope variables are set up</li> <li>Relevant scope's cache is checked to see if dependency was already provided before</li> <li>Provided instance is cached</li> <li>Concurrent-sensitive providers are resolved under lock, also double-checked locking is used</li> </ol> <p>Note</p> <p>Usually object id is appended to variable name (e.g. <code>DBConnection_140734497381936</code>) to avoid name conflicts,  here they're cleaned up.</p>"},{"location":"internals/writing-custom-provider-extensions/","title":"Writing Custom Provider Extensions","text":"<p><code>ProviderExtension</code> is what's responsible for extracting information from the provider - it's type,  dependencies, and how to resolve it.</p> <p>Here's an example extension that adds direct support for pydantic-settings <code>BaseSettings</code> class: <pre><code>from collections.abc import Mapping\nfrom typing import Any, TypeVar\n\nfrom pydantic_settings import BaseSettings\n\nfrom aioinject import Provider, Scope, SyncContainer\nfrom aioinject._internal.type_sources import TypeResolver\nfrom aioinject.extensions import ProviderExtension\nfrom aioinject.extensions.providers import (\n    CacheDirective,\n    ProviderInfo,\n    ResolveDirective,\n)\n\n\nTSettings = TypeVar(\"TSettings\", bound=BaseSettings)\n\n\nclass SettingsProvider(Provider[TSettings]):\n    def __init__(self, settings_cls: type[TSettings]) -&gt; None:\n        self.implementation = settings_cls\n\n    def provide(\n        self,\n        kwargs: dict[str, Any],  # noqa: ARG002\n    ) -&gt; TSettings:\n        return self.implementation()\n\n\nclass SettingsProviderExtension(\n    ProviderExtension[SettingsProvider[TSettings]],\n):\n    def supports_provider(self, provider: object) -&gt; bool:\n        return isinstance(provider, SettingsProvider)\n\n    def extract(\n        self,\n        provider: SettingsProvider[TSettings],\n        type_context: Mapping[str, type[object]],  # noqa: ARG002\n        type_resolver: TypeResolver,  # noqa: ARG002\n    ) -&gt; ProviderInfo[TSettings]:\n        return ProviderInfo(\n            interface=provider.implementation,\n            type_=provider.implementation,\n            dependencies=(),\n            scope=Scope.lifetime,\n            compilation_directives=(\n                ResolveDirective(is_async=False, is_context_manager=False),\n                CacheDirective(),\n            ),\n        )\n\n\nclass MySettings(BaseSettings):\n    env_value: int\n\n\ndef main() -&gt; None:\n    container = SyncContainer(extensions=[SettingsProviderExtension()])\n    container.register(SettingsProvider(MySettings))\n\n    with container, container.context() as ctx:\n        print(ctx.resolve(MySettings))  # env_value=...\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p>"}]}